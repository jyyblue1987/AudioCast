<script>
    class SoundBuffer {
        constructor(ctx, sampleRate, bufferSize = 6, debug = true) {
            this.ctx = ctx;
            this.sampleRate = sampleRate;
            this.bufferSize = bufferSize;
            this.debug = debug;
            this.chunks = [];
            this.isPlaying = false;
            this.startTime = 0;
            this.lastChunkOffset = 0;
        }
        createChunk(chunk) {
            var audioBuffer = this.ctx.createBuffer(2, chunk.length, this.sampleRate);
            audioBuffer.getChannelData(0).set(chunk);
            var source = this.ctx.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(this.ctx.destination);
            source.onended = (e) => {
                this.chunks.splice(this.chunks.indexOf(source), 1);
                if (this.chunks.length == 0) {
                    this.isPlaying = false;
                    this.startTime = 0;
                    this.lastChunkOffset = 0;
                }
            };
            return source;
        }
        log(data) {
            if (this.debug) {
                console.log(new Date().toUTCString() + " : " + data);
            }
        }
        addChunk(data) {
            if (this.isPlaying && (this.chunks.length > this.bufferSize)) {
                this.log("chunk discarded");
                return; // throw away
            }
            else if (this.isPlaying && (this.chunks.length <= this.bufferSize)) { // schedule & add right now
                this.log("chunk accepted");
                let chunk = this.createChunk(data);
                chunk.start(this.startTime + this.lastChunkOffset);
                this.lastChunkOffset += chunk.buffer.duration;
                this.chunks.push(chunk);
            }
            else if ((this.chunks.length < (this.bufferSize / 2)) && !this.isPlaying) { // add & don't schedule
                this.log("chunk queued");
                let chunk = this.createChunk(data);
                this.chunks.push(chunk);
            }
            else { // add & schedule entire buffer
                this.log("queued chunks scheduled");
                this.isPlaying = true;
                let chunk = this.createChunk(data);
                this.chunks.push(chunk);
                this.startTime = this.ctx.currentTime;
                this.lastChunkOffset = 0;
                for (let i = 0; i < this.chunks.length; i++) {
                    let chunk = this.chunks[i];
                    chunk.start(this.startTime + this.lastChunkOffset);
                    this.lastChunkOffset += chunk.buffer.duration;
                }
            }
        }
    }

    var audioBuffer = null;
    var context = null;
    window.addEventListener('load', init, false);
    var player = null;
    function init() {
        try {
            if(window.webkitAudioContext) {
                context = new window.webkitAudioContext();
            } else {
                context = new window.AudioContext();
            }

            player = new SoundBuffer(context, 44100, 2048, true);
        } catch(e) {
            alert('Web Audio API is not supported in this browser');
        }
    }

    var host = window.location.hostname;
    if( host == "" )
        host = "localhost";

    console.log(host);

    function audioChunkReceived (context, data, sample_rate) {
        var audioBuffer = context.createBuffer(2, 2048, sample_rate);
        audioBuffer.getChannelData(0).set(data);
        var source = context.createBufferSource(); // creates a sound source
        source.buffer = audioBuffer;
        source.connect(context.destination);
        source.start(0);
    }

    function decodeHandler(buffer) {
        console.log(data);
    }

    function WebSocketTest(port) {
        if ("WebSocket" in window) {
            // Let us open a web socket
            var ws = new WebSocket("ws://" + host + ":" + port);

            ws.onopen = function() {
                console.log("socket is connected")
            };

            ws.onmessage = function (event) {
                var data_type = typeof event.data;
                if ( data_type == "string" ) {
                    console.log(event.data);

                    return;
                }

                var reader = new FileReader();
                reader.readAsArrayBuffer(event.data);

                reader.onload = function(event) {
                    arrayBuffer = event.target.result;

                    // context.decodeAudioData(arrayBuffer, decodeHandler, function(e) { console.log(e); });
                    // audioChunkReceived(context, arrayBuffer, 44100);

                    var chunk = new Uint8Array(arrayBuffer);
                    if( player != null )
                        player.addChunk(chunk);
                };
            };

            ws.onclose = function() {
                // websocket is closed.
                console.log("Connection is closed...");
                setTimeout(function() {
                   WebSocketTest(port);
               }, 1000);
            };

            ws.onerror = function(err) {
                console.error(err);
                ws.close()
            }

        } else {
            // The browser doesn't support WebSocket
            console.log("WebSocket NOT supported by your Browser!");
        }
    }


    setTimeout(function() {
        init();
        WebSocketTest(9001);
    }, 500);

</script>
